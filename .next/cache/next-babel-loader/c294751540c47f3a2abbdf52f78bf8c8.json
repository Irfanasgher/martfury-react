{"ast":null,"code":"import Repository, { baseUrl, serializeQuery } from './Repository';\n\nclass CollectionRepository {\n  constructor(callback) {\n    this.callback = callback;\n  }\n\n  async getCollections(payload) {\n    let query = '';\n    payload.forEach(item => {\n      if (query === '') {\n        query = `slug_in=${item}`;\n      } else {\n        query = query + `&slug_in=${item}`;\n      }\n    });\n    const reponse = await Repository.get(`${baseUrl}/collections?${query}`).then(response => {\n      return response.data;\n    }).catch(error => ({\n      error: JSON.stringify(error)\n    }));\n    return reponse;\n  }\n\n  async getCategoriesBySlug(payload) {\n    let query = '';\n    payload.forEach(item => {\n      if (query === '') {\n        query = `slug_in=${item}`;\n      } else {\n        query = query + `&slug_in=${item}`;\n      }\n    });\n    const reponse = await Repository.get(`${baseUrl}/product-categories?${query}`).then(response => {\n      return response.data;\n    }).catch(error => ({\n      error: JSON.stringify(error)\n    }));\n    return reponse;\n  }\n\n  async getProductsBySlug(slug) {\n    const reponse = await Repository.get(`${baseUrl}/collections/slug?=${payload}`).then(response => {\n      return response.data;\n    }).catch(error => ({\n      error: JSON.stringify(error)\n    }));\n    return reponse;\n  }\n\n}\n\nexport default new CollectionRepository();","map":{"version":3,"sources":["C:/chc-ui/repositories/CollectionRepository.js"],"names":["Repository","baseUrl","serializeQuery","CollectionRepository","constructor","callback","getCollections","payload","query","forEach","item","reponse","get","then","response","data","catch","error","JSON","stringify","getCategoriesBySlug","getProductsBySlug","slug"],"mappings":"AAAA,OAAOA,UAAP,IAAqBC,OAArB,EAA8BC,cAA9B,QAAoD,cAApD;;AAEA,MAAMC,oBAAN,CAA2B;AACvBC,EAAAA,WAAW,CAACC,QAAD,EAAW;AAClB,SAAKA,QAAL,GAAgBA,QAAhB;AACH;;AAED,QAAMC,cAAN,CAAqBC,OAArB,EAA8B;AAC1B,QAAIC,KAAK,GAAG,EAAZ;AACAD,IAAAA,OAAO,CAACE,OAAR,CAAgBC,IAAI,IAAI;AACpB,UAAIF,KAAK,KAAK,EAAd,EAAkB;AACdA,QAAAA,KAAK,GAAI,WAAUE,IAAK,EAAxB;AACH,OAFD,MAEO;AACHF,QAAAA,KAAK,GAAGA,KAAK,GAAI,YAAWE,IAAK,EAAjC;AACH;AACJ,KAND;AAOA,UAAMC,OAAO,GAAG,MAAMX,UAAU,CAACY,GAAX,CAAgB,GAAEX,OAAQ,gBAAeO,KAAM,EAA/C,EACjBK,IADiB,CACZC,QAAQ,IAAI;AACd,aAAOA,QAAQ,CAACC,IAAhB;AACH,KAHiB,EAIjBC,KAJiB,CAIXC,KAAK,KAAK;AAAEA,MAAAA,KAAK,EAAEC,IAAI,CAACC,SAAL,CAAeF,KAAf;AAAT,KAAL,CAJM,CAAtB;AAKA,WAAON,OAAP;AACH;;AACD,QAAMS,mBAAN,CAA0Bb,OAA1B,EAAmC;AAC/B,QAAIC,KAAK,GAAG,EAAZ;AACAD,IAAAA,OAAO,CAACE,OAAR,CAAgBC,IAAI,IAAI;AACpB,UAAIF,KAAK,KAAK,EAAd,EAAkB;AACdA,QAAAA,KAAK,GAAI,WAAUE,IAAK,EAAxB;AACH,OAFD,MAEO;AACHF,QAAAA,KAAK,GAAGA,KAAK,GAAI,YAAWE,IAAK,EAAjC;AACH;AACJ,KAND;AAOA,UAAMC,OAAO,GAAG,MAAMX,UAAU,CAACY,GAAX,CACjB,GAAEX,OAAQ,uBAAsBO,KAAM,EADrB,EAGjBK,IAHiB,CAGZC,QAAQ,IAAI;AACd,aAAOA,QAAQ,CAACC,IAAhB;AACH,KALiB,EAMjBC,KANiB,CAMXC,KAAK,KAAK;AAAEA,MAAAA,KAAK,EAAEC,IAAI,CAACC,SAAL,CAAeF,KAAf;AAAT,KAAL,CANM,CAAtB;AAOA,WAAON,OAAP;AACH;;AAED,QAAMU,iBAAN,CAAwBC,IAAxB,EAA8B;AAC1B,UAAMX,OAAO,GAAG,MAAMX,UAAU,CAACY,GAAX,CACjB,GAAEX,OAAQ,sBAAqBM,OAAQ,EADtB,EAGjBM,IAHiB,CAGZC,QAAQ,IAAI;AACd,aAAOA,QAAQ,CAACC,IAAhB;AACH,KALiB,EAMjBC,KANiB,CAMXC,KAAK,KAAK;AAAEA,MAAAA,KAAK,EAAEC,IAAI,CAACC,SAAL,CAAeF,KAAf;AAAT,KAAL,CANM,CAAtB;AAOA,WAAON,OAAP;AACH;;AAjDsB;;AAoD3B,eAAe,IAAIR,oBAAJ,EAAf","sourcesContent":["import Repository, { baseUrl, serializeQuery } from './Repository';\r\n\r\nclass CollectionRepository {\r\n    constructor(callback) {\r\n        this.callback = callback;\r\n    }\r\n\r\n    async getCollections(payload) {\r\n        let query = '';\r\n        payload.forEach(item => {\r\n            if (query === '') {\r\n                query = `slug_in=${item}`;\r\n            } else {\r\n                query = query + `&slug_in=${item}`;\r\n            }\r\n        });\r\n        const reponse = await Repository.get(`${baseUrl}/collections?${query}`)\r\n            .then(response => {\r\n                return response.data;\r\n            })\r\n            .catch(error => ({ error: JSON.stringify(error) }));\r\n        return reponse;\r\n    }\r\n    async getCategoriesBySlug(payload) {\r\n        let query = '';\r\n        payload.forEach(item => {\r\n            if (query === '') {\r\n                query = `slug_in=${item}`;\r\n            } else {\r\n                query = query + `&slug_in=${item}`;\r\n            }\r\n        });\r\n        const reponse = await Repository.get(\r\n            `${baseUrl}/product-categories?${query}`\r\n        )\r\n            .then(response => {\r\n                return response.data;\r\n            })\r\n            .catch(error => ({ error: JSON.stringify(error) }));\r\n        return reponse;\r\n    }\r\n\r\n    async getProductsBySlug(slug) {\r\n        const reponse = await Repository.get(\r\n            `${baseUrl}/collections/slug?=${payload}`\r\n        )\r\n            .then(response => {\r\n                return response.data;\r\n            })\r\n            .catch(error => ({ error: JSON.stringify(error) }));\r\n        return reponse;\r\n    }\r\n}\r\n\r\nexport default new CollectionRepository();\r\n"]},"metadata":{},"sourceType":"module"}